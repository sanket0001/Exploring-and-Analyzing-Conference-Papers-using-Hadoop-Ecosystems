


Paper ID = 5815
Title = Fast Bidirectional Probability Estimation in Markov
Models
Siddhartha Banerjee ‚àó
sbanerjee@cornell.edu
Peter Lofgren‚Ä†
plofgren@cs.stanford.edu
Abstract
We develop a new bidirectional algorithm for estimating Markov chain multi-step
transition probabilities: given a Markov chain, we want to estimate the proba-
bility of hitting a given target state in ` steps after starting from a given source
distribution. Given the target state t, we use a (reverse) local power iteration to
construct an ‚Äòexpanded target distribution‚Äô, which has the same mean as the quan-
tity we want to estimate, but a smaller variance ‚Äì this can then be sampled effi-
ciently by a Monte Carlo algorithm. Our method extends to any Markov chain on
a discrete (finite or countable) state-space, and can be extended to compute func-
tions of multi-step transition probabilities such as PageRank, graph diffusions, hit-
ting/return times, etc. Our main result is that in ‚Äòsparse‚Äô Markov Chains ‚Äì wherein
the number of transitions between states is comparable to the number of states ‚Äì
the running time of our algorithm for a uniform-random target node is order-wise
smaller than Monte Carlo and power iteration based algorithms; in particular, our
method can estimate a probability p using only O(1/
‚àö
p) running time.
1 Introduction
Markov chains are one of the workhorses of stochastic modeling, finding use across a variety of
applications ‚Äì MCMC algorithms for simulation and statistical inference; to compute network cen-
trality metrics for data mining applications; statistical physics; operations management models for
reliability, inventory and supply chains, etc. In this paper, we consider a fundamental problem as-
sociated with Markov chains, which we refer to as the multi-step transition probability estimation
(or MSTP-estimation) problem: given a Markov Chain on state space S with transition matrix P ,
an initial source distribution œÉ over S, a target state t ‚àà S and a fixed length `, we are interested in
computing the `-step transition probability from œÉ to t. Formally, we want to estimate:
p`œÉ[t] := „ÄàœÉP `, et„Äâ = œÉP `eTt , (1)
where et is the indicator vector of state t. A natural parametrization for the complexity of MSTP-
estimation is in terms of the minimum transition probabilities we want to detect: given a desired
minimum detection threshold Œ¥, we want algorithms that give estimates which guarantee small rela-
tive error for any (œÉ, t, `) such that p`œÉ[t] > Œ¥.
Parametrizing in terms of the minimum detection threshold Œ¥ can be thought of as benchmarking
against a standard Monte Carlo algorithm, which estimates p`œÉ[t] by sampling independent `-step
paths starting from states sampled from œÉ. An alternate technique for MSTP-estimation is based on
linear algebraic iterations, in particular, the (local) power iteration. We discuss these in more detail
in Section 1.2. Crucially, however, both these techniques have a running time of ‚Ñ¶(1/Œ¥) for testing
if p`œÉ[t] > Œ¥ (cf. Section 1.2).
‚àóSiddhartha Banerjee is an assistant professor at the School of Operations Research and Information Engi-
neering at Cornell (http://people.orie.cornell.edu/sbanerjee).
‚Ä†Peter Lofgren is a graduate student in the Computer Science Department at Stanford (http://cs.
stanford.edu/people/plofgren/).
1
1.1 Our Results
To the best of our knowledge, our work gives the first bidirectional algorithm for MSTP-estimation
which works for general discrete state-space Markov chains1. The algorithm we develop is very
simple, both in terms of implementation and analysis. Moreover, we prove that in many settings, it
is order-wise faster than existing techniques.
Our algorithm consists of two distinct forward and reverse components, which are executed sequen-
tially. In brief, the two components proceed as follows:
‚Ä¢ Reverse-work: Starting from the target node t, we perform a sequence of reverse local power
iterations ‚Äì in particular, we use the REVERSE-PUSH operation defined in Algorithm 1.
‚Ä¢ Forward-work: We next sample a number of random walks of length `, starting from œÉ and
transitioning according to P , and return the sum of residues on the walk as an estimate of p`œÉ[t].
This full algorithm, which we refer to as the Bidirectional-MSTP estimator, is formalized in
Algorithm 2. It works for all countable-state Markov chains, giving the following accuracy result:
Theorem 1 (For details, refer Section 2.3). Given any Markov chain P , source distribution œÉ,
terminal state t, length `, threshold Œ¥ and relative error , Bidirectional-MSTP (Algorithm 2)
returns an unbiased estimate pÃÇ`œÉ[t] for p
`
œÉ[t], which, with high probability, satisfies:‚à£‚à£pÃÇ`œÉ[t]‚àí p`œÉ[t]‚à£‚à£ < max{p`œÉ[t], Œ¥} .
Since we dynamically adjust the number of REVERSE-PUSH operations to ensure that all residues
are small, the proof of the above theorem follows from straightforward concentration bounds.
Since Bidirectional-MSTP combines local power iteration and Monte Carlo techniques, a nat-
ural question is when the algorithm is faster than both. It is easy to to construct scenarios where the
runtime of Bidirectional-MSTP is comparable to its two constituent algorithms ‚Äì for example,
if t has more than 1/Œ¥ in-neighbors. Surprisingly, however, we show that in sparse Markov chains
and for typical target states, Bidirectional-MSTP is order-wise faster:
Theorem 2 (For details, refer Section 2.3). Given any Markov chain P , source distribution œÉ,
length `, threshold Œ¥ and desired accuracy ; then for a uniform random choice of t ‚àà S , the
Bidirectional-MSTP algorithm has a running time of OÃÉ(`3/2
‚àö
d/Œ¥), where d is the average
number of neighbors of nodes in S.
Thus, for typical targets, we can estimate transition probabilities of order Œ¥ in time only O(1/
‚àö
Œ¥).
Note that we do not need for every state that the number of neighboring states is small, but rather,
that they are small on average ‚Äì for example, this is true in ‚Äòpower-law‚Äô networks, where some
nodes have very high degree, but the average degree is small. The proof of this result is based on a
modification of an argument in [2] ‚Äì refer Section 2.3 for details.
Estimating transition probabilities to a target state is one of the fundamental primitives in Markov
chain models ‚Äì hence, we believe that our algorithm can prove useful in a variety of application
domains. In Section 3, we briefly describe how to adapt our method for some of these applica-
tions ‚Äì estimating hitting/return times and stationary probabilities, extensions to non-homogenous
Markov chains (in particular, for estimating graph diffusions and heat kernels), connections to lo-
cal algorithms and expansion testing. In addition, our MSTP-estimator could be useful in several
other applications ‚Äì estimating ruin probabilities in reliability models, buffer overflows in queueing
systems, in statistical physics simulations, etc.
1.2 Existing Approaches for MSTP-Estimation
There are two main techniques used for MSTP-estimation. The first is a natural Monte Carlo al-
gorithm: we estimate p`œÉ[t] by sampling independent `-step paths, each starting from a random
state sampled from œÉ. A simple concentration argument shows that for a given value of Œ¥, we need
ŒòÃÉ(1/Œ¥) samples to get an accurate estimate of p`œÉ[t], irrespective of the choice of t, and the structure
1Bidirectional estimators have been developed before for reversible Markov chains [1]; our method however
is not only more general, but conceptually and operationally simpler than these techniques (cf. Section 1.2).
2
of P . Note that this algorithm is agnostic of the terminal state t; it gives an accurate estimate for any
t such that p`œÉ[t] > Œ¥.
On the other hand, the problem also admits a natural linear algebraic solution, using the standard
power iteration starting with œÉ, or the reverse power iteration starting with et (which is obtained
by re-writing Equation (1) as p`œÉ[t] := œÉ(et(P
T )`)T ). When the state space is large, performing a
direct power iteration is infeasible ‚Äì however, there are localized versions of the power iteration that
are still efficient. Such algorithms have been developed, among other applications, for PageRank
estimation [3, 4] and for heat kernel estimation [5]. Although slow in the worst case 2, such local
update algorithms are often fast in practice, as unlike Monte Carlo methods they exploit the local
structure of the chain. However even in sparse Markov chains and for a large fraction of target
states, their running time can be ‚Ñ¶(1/Œ¥). For example, consider a random walk on a random d-
regular graph and let Œ¥ = o(1/n) ‚Äì then for ` ‚àº logd(1/Œ¥), verifying p`es [t] > Œ¥ is equivalent to
uncovering the entire logd(1/Œ¥) neighborhood of s. Since a large random d-regular graph is (whp)
an expander, this neighborhood has ‚Ñ¶(1/Œ¥) distinct nodes. Finally, note that as with Monte Carlo,
power iterations can be adapted to either the source or terminal state, but not both.
For reversible Markov chains, one can get a bidirectional algorithms for estimating p`es [t] based on
colliding random walks. For example, consider the problem of estimating length-2` random walk
transition probabilities in a regular undirected graph G(V,E) on n vertices [1, 6]. The main idea
is that to test if a random walk goes from s to t in 2` steps with probability ‚â• Œ¥, we can generate
two independent random walks of length `, starting from s and t respectively, and detect if they
terminate at the same intermediate node. Suppose pw, qw are the probabilities that a length-` walk
from s and t respectively terminate at node w ‚Äì then from the reversibility of the chain, we have that
p2`œÉ [t] =
‚àë
w‚ààV pwqw; this is also the collision probability. The critical observation is that if we
generate
‚àö
1/Œ¥ walks from s and t, then we get 1/Œ¥ potential collisions, which is sufficient to detect
if p2`œÉ [t] > Œ¥. This argument forms the basis of the birthday-paradox, and similar techniques used
in a variety of estimation problems (eg., see [7]). Showing concentration for this estimator is tricky
as the samples are not independent; moreover, to control the variance of the samples, the algorithms
often need to separately deal with ‚Äòheavy‚Äô intermediate nodes, where pw or qw are much larger than
O(1/n). Our proposed approach is much simpler both in terms of algorithm and analysis, and more
significantly, it extends beyond reversible chains to any general discrete state-space Markov chain.
The most similar approach to ours is the recent FAST-PPR algorithm of Lofgren et al. [2] for PageR-
ank estimation; our algorithm borrows several ideas and techniques from that work. However, the
FAST-PPR algorithm relies heavily on the structure of PageRank ‚Äì in particular, the fact that the
PageRank walk has Geometric(Œ±) length (and hence can be stopped and restarted due to the mem-
oryless property). Our work provides an elegant and powerful generalization of the FAST-PPR
algorithm, extending the approach to general Markov chains.
2 The Bidirectional MSTP-estimation Algorithm
2.1 Algorithm
As described in Section 1.1, given a target state t, our bidirectional MSTP algorithm keeps track of
a pair of vectors ‚Äì the estimate vector qkt ‚àà Rn and the residual vector rkt ‚àà Rn ‚Äì for each length
k ‚àà {0, 1, 2, . . . , `}. The vectors are initially all set to 0 (i.e., the all-0 vector), except r0t which is
initialized as et. Moreover, they are updated using a reverse push operation defined as:
Algorithm 1 REVERSE-PUSH(v, i)
Inputs: Transition matrix P , estimate vector qit, residual vectors rit, r
i+1
t
1: return New estimate vectors {qÃÉit} and residual-vectors {rÃÉit} computed as:
qÃÉit ‚Üê qit + „Äàrit, ev„Äâev; rÃÉit ‚Üê rit ‚àí „Äàrit, ev„Äâev; rÃÉi+1t ‚Üê ri+1t + „Äàrit, ev„Äâ
(
evP
T
)
2In particular, local power iterations are slow if a state has a very large out-neighborhood (for the forward
iteration) or in-neighborhood (for the reverse update).
3
The main observation behind our algorithm is that we can re-write p`œÉ[t] in terms of {qkt , rkt } as an
expectation over random sample-paths of the Markov chain as follows (cf. Equation (3)):
p`œÉ[t] = „ÄàœÉ,q`t„Äâ+
‚àëÃÄ
k=0
EVk‚àºœÉPk
[
r`‚àíkt (Vk)
]
(2)
In other words, given vectors {qkt , rkt }, we can get an unbiased estimator for p`œÉ[t] by sampling a
length-` random trajectory {V0, V1, . . . , V`} of the Markov chain P starting at a random state V0
sampled from the source distribution œÉ, and then adding the residuals along the trajectory as in
Equation (2). We formalize this bidirectional MSTP algorithm in Algorithm 2.
Algorithm 2 Bidirectional-MSTP(P, œÉ, t, `max, Œ¥)
Inputs: Transition matrix P , source distribution œÉ, target state t, maximum steps `max, minimum
probability threshold Œ¥, relative error bound , failure probability pf
1: Set accuracy parameter c based on  and pf and set reverse threshold Œ¥r (cf. Theorems 1 and 2)
(in our experiments we use c = 7 and Œ¥r =
‚àö
Œ¥/c)
2: Initialize: Estimate vectors qkt = 0 , ‚àÄ k ‚àà {0, 1, 2, . . . , `},
Residual vectors r0t = et and r
k
t = 0 , ‚àÄ k ‚àà {1, 2, 3, . . . , `}
3: for i ‚àà {0, 1, . . . , `max} do
4: while ‚àÉ v ‚àà S s.t. rit[v] > Œ¥r do
5: Execute REVERSE-PUSH(v, i)
6: end while
7: end for
8: Set number of sample paths nf = c`maxŒ¥r/Œ¥ (See Theorem 1 for details)
9: for index i ‚àà {1, 2, . . . , nf} do
10: Sample starting node V 0i ‚àº œÉ
11: Generate sample path Ti = {V 0i , V 1i , . . . , V
`max
i } of length `max starting from V 0i
12: For ` ‚àà {1, 2, . . . , `max}: sample k ‚àº Uniform[0, `] and compute S`t,i = `r
`‚àík
t [V
k
i ]
(We reinterpret the sum over k in Equation 2 as an expectation and sample k rather sum over
k ‚â§ ` for computational speed.)
13: end for
14: return {pÃÇ`œÉ[t]}`‚àà[`max], where pÃÇ`œÉ[t] = „ÄàœÉ,q`t„Äâ+ (1/nf )
‚àënf
i=1 S
`
t,i
2.2 Some Intuition Behind our Approach
Before formally analyzing the performance of our MSTP-estimation algorithm, we first build some
intuition as to why it works. In particular, it is useful to interpret the estimates and residues in
probabilistic/combinatorial terms. In Figure 1, we have considered a simple Markov chain on three
states ‚Äì Solid, Hollow and Checkered (henceforth (S,H,C)). On the right side, we have illustrated
an intermediate stage of reverse work using S as the target, after performing the REVERSE-PUSH
operations (S, 0), (H, 1), (C, 1) and (S, 2) in that order. Each push at level i uncovers a collection
Figure 1: Visualizing a sequence of REVERSE-PUSH operations: Given the Markov chain on the
left with S as the target, we perform REVERSE-PUSH operations (S, 0), (H, 1), (C, 1),(S, 2).
4
of length-(i + 1) paths terminating at S ‚Äì for example, in the figure, we have uncovered all length
2 and 3 paths, and several length 4 paths. The crucial observation is that each uncovered path of
length i starting from a node v is accounted for in either qiv or r
i
v . In particular, in Figure 1, all paths
starting at solid nodes are stored in the estimates of the corresponding states, while those starting at
blurred nodes are stored in the residue. Now we can use this set of pre-discovered paths to boost the
estimate returned by Monte Carlo trajectories generated starting from the source distribution. The
dotted line in the figure represents the current reverse-work frontier ‚Äì it separates the fully uncovered
neighborhood of (S, 0) from the remaining states (v, i).
In a sense, what the REVERSE-PUSH operation does is construct a sequence of importance-
sampling weights, which can then be used for Monte Carlo. An important novelty here is that
the importance-sampling weights are: (i) adapted to the target state, and (ii) dynamically adjusted
to ensure the Monte Carlo estimates have low variance. Viewed in this light, it is easy to see how
the algorithm can be modified to applications beyond basic MSTP-estimation: for example, to non-
homogenous Markov chains, or for estimating the probability of hitting a target state t for the first
time in ` steps (cf. Section 3). Essentially, we only need an appropriate reverse-push/dynamic
programming update for the quantity of interest (with associated invariant, as in Equation (2)).
2.3 Performance Analysis
We first formalize the critical invariant introduced in Equation (2):
Lemma 1. Given a terminal state t, suppose we initialize q0t = 0, r0t = et and qkt , rkt = 0 ‚àÄ k ‚â•
0. Then for any source distribution œÉ and length `, after any arbitrary sequence of REVERSE-
PUSH(v, k) operations, the vectors {qkt , rkt } satisfy the invariant:
p`œÉ[t] = „ÄàœÉ,q`t„Äâ+
‚àëÃÄ
k=0
„ÄàœÉP k, r`‚àíkt „Äâ (3)
The proof follows the outline of a similar result in Andersen et al. [4] for PageRank estimation; due
to lack of space, we defer it to our full version [8]. Using this result, we can now characterize the
accuracy of the Bidirectional-MSTP algorithm:
Theorem 1. We are given any Markov chain P , source distribution œÉ, terminal state t, maximum
length `max and also parameters Œ¥, pf and  (i.e., the desired threshold, failure probability and
relative error). Suppose we choose any reverse threshold Œ¥r > Œ¥, and set the number of sample-
paths nf = cŒ¥r/Œ¥, where c = max
{
6e/2, 1/ ln 2
}
ln (2`max/pf ). Then for any length ` ‚â§ `max
with probability at least 1‚àí pf , the estimate returned by Bidirectional-MSTP satisfies:‚à£‚à£pÃÇ`œÉ[t]‚àí p`œÉ[t]‚à£‚à£ < max{p`œÉ[t], Œ¥} .
Proof. Given any Markov chain P and terminal state t, note first that for a given length ` ‚â§ `max,
Equation (2) shows that the estimate pÃÇ`œÉ[t] is an unbiased estimator. Now, for any random-trajectory
Tk, we have that the score S`t,k obeys: (i) E[S`t,k] ‚â§ p`œÉ[t] and (ii) S`t,k ‚àà [0, `Œ¥r]; the first in-
equality again follows from Equation (2), while the second follows from the fact that we executed
REVERSE-PUSH operations until all residual values were less than Œ¥r.
Now consider the rescaled random variable Xk = S`t,k/(`Œ¥r) and X =
‚àë
k‚àà[nf ]Xk; then we
have that Xk ‚àà [0, 1], E[X] ‚â§ (nf/`Œ¥r)p`œÉ[t] and also (X ‚àí E[X]) = (nf/`Œ¥r)(pÃÇ`œÉ[t] ‚àí p`œÉ[t]).
Moreover, using standard Chernoff bounds (cf. Theorem 1.1 in [9]), we have that:
P [|X ‚àí E[X]| > E[X]] < 2 exp
(
‚àí
2E[X]
3
)
and P[X > b] ‚â§ 2‚àíb for any b > 2eE[X]
Now we consider two cases:
1. E[S`t,k] > Œ¥/2e (i.e., E[X] > nfŒ¥/2e`Œ¥r = c/2e): Here, we can use the first concentration
bound to get:
P
[‚à£‚à£pÃÇ`œÉ[t]‚àí p`œÉ[t]‚à£‚à£ ‚â• p`œÉ[t]] = P [|X ‚àí E[X]| ‚â• nf`Œ¥r p`œÉ[t]
]
‚â§ P [|X ‚àí E[X]| ‚â• E[X]]
‚â§ 2 exp
(
‚àí
2E[X]
3
)
‚â§ 2 exp
(
‚àí
2c
6e
)
,
5
where we use that nf = c`maxŒ¥r/Œ¥ (cf. Algorithm 2). Moreover, by the union bound, we have:
P
Ô£ÆÔ£∞ ‚ãÉ
`‚â§`max
{‚à£‚à£pÃÇ`œÉ[t]‚àí p`œÉ[t]‚à£‚à£ ‚â• p`œÉ[t]}
Ô£πÔ£ª ‚â§ 2`max exp(‚àí 2c
32e
)
,
Now as long as c ‚â•
(
6e/2
)
ln (2`max/pf ), we get the desired failure probability.
2. E[S`t,k] < Œ¥/2e (i.e., E[X] < c/2e): In this case, note first that since X > 0, we have that
p`œÉ[t]‚àí pÃÇ`œÉ[t] ‚â§ (nf/`Œ¥r)E[X] ‚â§ Œ¥/2e < Œ¥. On the other hand, we also have:
P
[
pÃÇ`œÉ[t]‚àí p`œÉ[t] ‚â• Œ¥
]
= P
[
X ‚àí E[X] ‚â• nfŒ¥
`Œ¥r
]
‚â§ P [X ‚â• c] ‚â§ 2‚àíc,
where the last inequality follows from our second concentration bound, which holds since we
have c > 2eE[X]. Now as before, we can use the union bound to show that the failure probability
is bounded by pf as long as c ‚â• log2 (`max/pf ).
Combining the two cases, we see that as long as c ‚â• max
{
6e/2, 1/ ln 2
}
ln (2`max/pf ), then we
have P
[‚ãÉ
`‚â§`max
{‚à£‚à£pÃÇ`œÉ[t]‚àí p`œÉ[t]‚à£‚à£ ‚â• max{Œ¥, p`œÉ[t]}}] ‚â§ pf .
One aspect that is not obvious from the intuition in Section 2.2 or the accuracy analysis is if using a
bidirectional method actually improves the running time of MSTP-estimation. This is addressed by
the following result, which shows that for typical targets, our algorithm achieves significant speedup:
Theorem 2. Let any Markov chain P , source distribution œÉ, maximum length `max and parameters
Œ¥, pf and  be given. Suppose we set Œ¥r =
‚àö
2Œ¥
`max log(`max/pf )
. Then for a uniform random choice of
t ‚àà S, the Bidirectional-MSTP algorithm has a running time of OÃÉ
(
`
3/2
max
‚àö
d/Œ¥
)
.
Proof. The runtime of Algorithm 2 consists of two parts:
Forward-work (i.e., for generating trajectories): we generate nf = c`maxŒ¥r/Œ¥ sample trajectories,
each of length `max ‚Äì hence the running time is O
(
cŒ¥`2max/Œ¥
)
for any Markov chain P , source
distribution œÉ and target node t. Substituting for c from Theorem 1, we get that the forward-work
running time Tf = O
(
`2maxŒ¥r log(`max/pf )
2Œ¥
)
.
Reverse-work (i.e., for REVERSE-PUSH operations): Let Tr denote the reverse-work runtime for
a uniform random choice of t ‚àà S. Then we have:
E[Tr] =
1
|S|
‚àë
t‚ààS
`max‚àë
k=0
‚àë
v‚ààS
(din(v) + 1)1{REVERSE-PUSH(v,k) is executed}
Now for a given t ‚àà S and k ‚àà {0, 1, . . . , `max}, note that the only states v ‚àà S on which we
execute REVERSE-PUSH(v, k) are those with residual rkt (v) > Œ¥r ‚Äì consequently, for these states,
we have that qkt (v) > Œ¥r, and hence, by Equation (3), we have that p
k
ev
[t] ‚â• Œ¥r (by setting œÉ = ev ,
i.e., starting from state v). Moreover, a REVERSE-PUSH(v, k) operation involves updating the
residuals for din(v)+1 states. Note that
‚àë
t‚ààS p
k
ev
[t] = 1 and hence, via a straightforward counting
argument, we have that for any v ‚àà S,
‚àë
t‚ààS 1{pkev [t]‚â•Œ¥r}
‚â§ 1/Œ¥r. Thus, we have:
E[Tr] ‚â§
1
|S|
‚àë
t‚ààS
`max‚àë
k=0
‚àë
v‚ààS
(din(v) + 1)1{pkev [t]‚â•Œ¥r}
=
1
|S|
‚àë
v‚ààS
`max‚àë
k=0
‚àë
t‚ààS
(din(v) + 1)1{pkev [t]‚â•Œ¥r}
‚â§ 1
|S|
‚àë
v‚ààS
(`max + 1) ¬∑ (din(v) + 1)
1
Œ¥r
= O
(
`max
Œ¥r
¬∑
‚àë
v‚ààS d
in(v)
|S|
)
= O
(
`maxd
Œ¥r
)
Finally, we choose Œ¥r =
‚àö
2Œ¥
`max log(`max/pf )
to balance Tf and Tr and get the result.
6
3 Applications of MSTP estimation
‚Ä¢ Estimating the Stationary Distribution and Hitting Probabilities: MSTP-estimation can be
used in two ways to estimate stationary probabilities œÄ[t]. First, if we know the mixing time œÑmix
of the chain P , we can directly use Algorithm 2 to approximate œÄ[t] by setting `max = œÑmix and
using any source distribution œÉ. Theorem 2 then guarantees that we can estimate a stationary
probability of order Œ¥ in time O(œÑ3/2mix
‚àö
d/Œ¥). In comparison, Monte Carlo has O(œÑmix/Œ¥) run-
time. We note that in practice, we usually do not know the mixing time ‚Äì in such a setting, our
algorithm can be used to compute an estimate of p`œÉ[t] for all values of ` ‚â§ `max.
An alternative is to modify Algorithm 2 to estimate the truncated hitting time pÃÇ`,hitœÉ [t](i.e., the
probability of hitting t starting from œÉ for the first time in ` steps). By setting œÉ = et, we get
an estimate for the expected truncated return time E[Tt1{Tt‚â§`max}] =
‚àë
`‚â§`max `pÃÇ
`,hit
et
[t]. Now,
using that fact that œÄ[t] = 1/E[Tt], we can get a lower bound for œÄ[t] which converges to œÄ[t]
as `max ‚Üí ‚àû. We note also that the truncated hitting time has been shown to be useful in other
applications such as identifying similar documents on a document-word-author graph [10].
To estimate the truncated hitting time, we modify Algorithm 2 as follows: at each stage i ‚àà
{1, 2, . . . , `max} (note: not i = 0), instead of REVERSE-PUSH(t, i), we update qÃÉit[t] = qit[t] +
rit[t], set rÃÉ
i
t[t] = 0 and do not push back r
i
t[t] to the in-neighbors of t in the (i + 1)
th stage. The
remaining algorithm remains the same. It is easy to see from the discussion in Section 2.2 that the
resulting quantity pÃÇ`,hitœÉ [t] is an unbiased estimate of P[Hitting time of t = `|X0 ‚àº œÉ] ‚Äì we omit
a formal proof due to lack of space.
‚Ä¢ Exact Stationary Probabilities in Strong Doeblin chains: A strong Doeblin chain [11] is ob-
tained by mixing a Markov chain P and a distribution œÉ as follows: at each transition, the pro-
cess proceeds according to P with probability Œ±, else samples a state from œÉ. Doeblin chains are
widely used in ML applications ‚Äì special cases include the celebrated PageRank metric [12], vari-
ants such as HITS and SALSA [13], and other algorithms for applications such as ranking [14] and
structured prediction [15]. An important property of these chains is that if we sample a starting
node V0 from œÉ and sample a trajectory of lengthGeometric(Œ±) starting from V0, then the termi-
nal node is an unbiased sample from the stationary distribution [16]. There are two ways in which
our algorithm can be used for this purpose: one is to replace the REVERSE-PUSH algorithm with
a corresponding local update algorithm for the strong Doeblin chain (similar to the one in Ander-
sen et al. [4] for PageRank), and then sample random trajectories of length Geometric(Œ±). A
more direct technique is to choose some `max >> 1/Œ±, estimate {p`œÉ[t]} ‚àÄ ` ‚àà [`max] and then
directly compute the stationary distribution as p[t] =
‚àë`max
`=1 Œ±
`‚àí1(1‚àí Œ±)p`œÉ[t].
‚Ä¢ Graph Diffusions: If we assign a weight Œ±i to random walks of length i on a (weighted)
graph, the resulting scoring functions f(P, œÉ)[t] :=
‚àë‚àû
i=0 Œ±i
(
œÉTP i
)
[t] are known as a graph
diffusions [17] and are used in a variety of applications. The case where Œ±i = Œ±i‚àí1(1 ‚àí Œ±)
corresponds to PageRank. If instead the length is drawn according to a Poisson distribution
(i.e., Œ±i = e‚àíŒ±Œ±i/i!), then the resulting function is called the heat-kernel h(G,Œ±) ‚Äì this too
has several applications, including finding communities (clusters) in large networks [5]. Note
that for any function f as defined above, the truncated sum f `max =
‚àë`max
i=0 Œ±i
(
pTœÉP
i
)
obeys
||f ‚àí f `max ||‚àû ‚â§
‚àë‚àû
`max+1
Œ±i. Thus a guarantee on an estimate for the truncated sum directly
translates to a guarantee on the estimate for the diffusion. We can use MSTP-estimation to effi-
ciently estimate these truncated sums. We perform numerical experiments on heat kernel estima-
tion in the next section.
‚Ä¢ Conductance Testing in Graphs: MSTP-estimation is an essential primitive for conductance
testing in large Markov chains [1]. In particular, in regular undirected graphs, Kale et al [6]
develop a sublinear bidirectional estimator based on counting collisions between walks in order
to identify ‚Äòweak‚Äô nodes ‚Äì those which belong to sets with small conductance. Our algorithm can
be used to extend this process to any graph, including weighted and directed graphs.
‚Ä¢ Local Algorithms: There is a lot of interest recently on local algorithms ‚Äì those which perform
computations given only a small neighborhood of a source node [18]. In this regard, we note that
Bidirectional-MSTP gives a natural local algorithm for MSTP estimation, and thus for the
applications mentioned above ‚Äì given a k-hop neighborhood around the source and target, we can
perform Bidirectional-MSTP with `max set to k. The proof of this follows from the fact
that the invariant in Equation (2) holds after any sequence of REVERSE-PUSH operations.
7
Figure 2: Estimating heat kernels: Bidirectional MSTP-estimation vs. Monte Carlo, Forward Push.
To compare runtimes, we choose parameters such that the mean relative error of all algorithms is
around 10%. Notice that Bidirectional-MSTP is 100 times faster than the other algorithms.
4 Experiments
To demonstrate the efficiency of our algorithm on large Markov chains, we use heat kernel esti-
mation (cf. Section 3) as an example application. The heat kernel is a non-homogenous Markov
chain, defined as the probability of stopping at the target on a random walk from the source, where
the walk length is sampled from a Poisson(`) Distribution. In real-world graphs, a heat-kernel
value between a pair of nodes has been shown to be a good indicator of an underlying community
relationship [5] ‚Äì this suggests that it can serve as a metric for personalized search on social net-
works. For example, if a social network user s wants to view a list of users attending some event,
then sorting these users by heat kernel values will result in the most similar users to s appearing on
top. Bidirectional-MSTP is ideal for such personalized search applications, as the set of users
filtered by a search query is typically much smaller than the set of nodes on the network.
In Figure 2, we compare the runtime of different algorithms for heat kernel computation on four
real-world graphs, ranging from millions to billions of edges 3. For each graph, for random (source,
target) pairs, we compute the heat kernel using Bidirectional-MSTP, as well as two bench-
mark algorithms ‚Äì Monte Carlo, and the Forward Push algorithm (as presented in [5]). All three
algorithms have parameters which allow them to trade off speed and accuracy ‚Äì for a fair compar-
ison, we choose parameters such that the empirical mean relative error each algorithm is 10%. All
three algorithms were implemented in Scala ‚Äì for the forward push algorithm, our implementation
follows the code linked from [5]).
We set average walk-length ` = 5 (since longer walks will mix into the stationary distribution), and
set the maximum length to `+10
‚àö
` ‚âà 27; the probability of a walk being longer than this is 10‚àí12,
which is negligible. For reproducibility, our source code is available on our website (cf. [8]).
Figure 2 shows that across all graphs, Bidirectional-MSTP is 100x faster than the two bench-
mark algorithms. For example, on the Twitter graph, it can estimate a heat kernel score is 0.1
seconds, while the the other algorithms take more than 4 minutes. We note though that Monte Carlo
and Forward Push can return scores from the source to all targets, rather than just one target ‚Äì thus
Bidirectional-MSTP is most useful when we want the score for a small set of targets.
Acknowledgments
Research supported by the DARPA GRAPHS program via grant FA9550-12-1-0411, and by NSF
grant 1447697. Peter Lofgren was supported by an NPSC fellowship. Thanks to Ashish Goel and
other members of the Social Algorithms Lab at Stanford for many helpful discussions.
3Pokec [19], Live Journal [20], and Orkut [20] datasets are from the SNAP [21]; Twitter-2010 [22] was
downloaded from the Laboratory for Web Algorithmics [23]. Refer to our full version [8] for details.
8
References
[1] Oded Goldreich and Dana Ron. On testing expansion in bounded-degree graphs. In Studies in Complexity
and Cryptography. Miscellanea on the Interplay between Randomness and Computation. Springer, 2011.
[2] Peter Lofgren, Siddhartha Banerjee, Ashish Goel, and C Seshadhri. FAST-PPR: Scaling personalized
PageRank estimation for large graphs. In ACM SIGKDD‚Äô14, 2014.
[3] Reid Andersen, Fan Chung, and Kevin Lang. Local graph partitioning using PageRank vectors. In IEEE
FOCS‚Äô06, 2006.
[4] Reid Andersen, Christian Borgs, Jennifer Chayes, John Hopcraft, Vahab S Mirrokni, and Shang-Hua
Teng. Local computation of PageRank contributions. In Algorithms and Models for the Web-Graph.
Springer, 2007.
[5] Kyle Kloster and David F Gleich. Heat kernel based community detection. In ACM SIGKDD‚Äô14, 2014.
[6] Satyen Kale, Yuval Peres, and C Seshadhri. Noise tolerance of expanders and sublinear expander recon-
struction. In IEEE FOCS‚Äô08, 2008.
[7] Rajeev Motwani, Rina Panigrahy, and Ying Xu. Estimating sum by weighted sampling. In Automata,
Languages and Programming, pages 53‚Äì64. Springer, 2007.
[8] Siddhartha Banerjee and Peter Lofgren. Fast bidirectional probability estimation in markov models. Tech-
nical report, 2015. http://arxiv.org/abs/1507.05998.
[9] Devdatt P Dubhashi and Alessandro Panconesi. Concentration of measure for the analysis of randomized
algorithms. Cambridge University Press, 2009.
[10] Purnamrita Sarkar, Andrew W Moore, and Amit Prakash. Fast incremental proximity search in large
graphs. In Proceedings of the 25th international conference on Machine learning, pages 896‚Äì903. ACM,
2008.
[11] Wolfgang Doeblin. Elements d‚Äôune theorie generale des chaines simples constantes de markoff. In
Annales Scientifiques de l‚ÄôEcole Normale SupeÃÅrieure, volume 57, pages 61‚Äì111. SocieÃÅteÃÅ matheÃÅmatique
de France, 1940.
[12] Lawrence Page, Sergey Brin, Rajeev Motwani, and Terry Winograd. The pagerank citation ranking:
bringing order to the web. 1999.
[13] Ronny Lempel and Shlomo Moran. The stochastic approach for link-structure analysis (SALSA) and the
TKC effect. Computer Networks, 33(1):387‚Äì401, 2000.
[14] Sahand Negahban, Sewoong Oh, and Devavrat Shah. Iterative ranking from pair-wise comparisons. In
Advances in Neural Information Processing Systems, pages 2474‚Äì2482, 2012.
[15] Jacob Steinhardt and Percy Liang. Learning fast-mixing models for structured prediction. In ICML‚Äô15,
2015.
[16] Krishna B Athreya and OÃàrjan Stenflo. Perfect sampling for Doeblin chains. SankhyaÃÑ: The Indian Journal
of Statistics, pages 763‚Äì777, 2003.
[17] Fan Chung. The heat kernel as the pagerank of a graph. Proceedings of the National Academy of Sciences,
104(50):19735‚Äì19740, 2007.
[18] Christina E Lee, Asuman Ozdaglar, and Devavrat Shah. Computing the stationary distribution locally. In
Advances in Neural Information Processing Systems, pages 1376‚Äì1384, 2013.
[19] Lubos Takac and Michal Zabovsky. Data analysis in public social networks. In International. Scientific
Conf. & Workshop Present Day Trends of Innovations, 2012.
[20] Alan Mislove, Massimiliano Marcon, Krishna P. Gummadi, Peter Druschel, and Bobby Bhattacharjee.
Measurement and Analysis of Online Social Networks. In Proceedings of the 5th ACM/Usenix Internet
Measurement Conference (IMC‚Äô07), San Diego, CA, October 2007.
[21] Stanford Network Analysis Platform (SNAP). http://http://snap.stanford.edu/. Ac-
cessed: 2014-02-11.
[22] Paolo Boldi, Marco Rosa, Massimo Santini, and Sebastiano Vigna. Layered label propagation: A multi
resolution coordinate-free ordering for compressing social networks. In ACM WWW‚Äô11, 2011.
[23] Laboratory for Web Algorithmics. http://law.di.unimi.it/datasets.php. Accessed: 2014-
02-11.
9
